package main

//简述一下你对Go垃圾回收机制的理解？

//常见的垃圾回收方法:
//引用计数：对每个对象维护一个引用计数，当引用该对象的对象被销毁时，引用计数减1，当引用计数器为0是回收该对象。
//优点：对象可以很快的被回收，不会出现内存耗尽或达到某个阀值时才回收。
//缺点：不能很好的处理循环引用，而且实时维护引用计数，有也一定的代价。
//代表语言：Python、PHP
//
//标记-清除：从根变量开始遍历所有引用的对象，引用的对象标记为"被引用"，没有被标记的进行回收。
//优点：解决了引用计数的缺点。
//缺点：需要STW，即要暂时停掉程序运行。
//代表语言：Golang(其采用三色标记法)
//
//分代收集：按照对象生命周期长短划分不同的代空间，生命周期长的放入老年代，
//而短的放入新生代，不同代有不能的回收算法和回收频率。
//优点：回收性能好
//缺点：实现复杂
//代表语言： JAVA
//
//
//root
//首先标记root根对象，根对象的子对象也是存活的。
//根对象包括：全局变量，各个stack上的变量等。
//
//三色标记
//灰色：对象已被标记，但这个对象包含的子对象未标记
//黑色：对象已被标记，且这个对象包含的子对象也已标记
//白色：对象未被标记
//
//GC步骤
//初始状态下所有对象都是白色的。(未被标记)
//首先标记root对象为灰色,放入待处理队列。
//取出待处理队列的灰色对象,将其引用标记为灰色,放入待处理队列,并将本身标记为黑色.
//循环第三步,直到待处理队列为空(在标记过程中的新的引用对象,通过写屏障直接标记为灰色),
//此时剩下的只有白色和黑色,白色对象则表示不可达,将其清理.

//触发GC的机制
//在申请内存的时候，检查当前当前已分配的内存是否大于上次GC后的内存的2倍
//(可配置GOGC参数,即百分比,默认是100)， 若是则触发.
//
//监控线程发现上次GC的时间已经超过两分钟了，触发
//
//手动：runtime.gc()


func main() {
	
}
